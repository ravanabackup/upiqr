<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live QR Code Error Correction Demo</title>
    <!-- qrcode.js for generating QR codes -->
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <!-- jsQR for reading QR codes -->
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #3498db, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            color: #34495e;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
            font-size: 1.8em;
        }

        h3 {
            color: #2980b9;
            margin: 20px 0 15px 0;
            font-size: 1.4em;
        }

        .section {
            margin-bottom: 40px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #3498db;
        }

        .formula {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            border: 2px solid #007bff;
            position: relative;
            overflow-x: auto;
        }

        .formula::before {
            content: "üìê";
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
        }

        .live-demo {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .demo-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        input, button, select {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        input {
            border: 2px solid #ddd;
            background: white;
            color: #333;
            min-width: 200px;
        }

        input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }

        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            cursor: pointer;
            font-weight: bold;
            border: none;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .qr-workspace {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin: 30px 0;
        }

        .qr-display {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .qr-canvas {
            border: 3px solid #34495e;
            border-radius: 10px;
            margin: 15px auto;
            display: block;
            max-width: 100%;
            cursor: crosshair;
        }

        .qr-info {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            min-height: 150px;
            text-align: left;
        }

        .damage-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .damage-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            font-size: 0.9em;
            padding: 8px 16px;
        }

        .repair-btn {
            background: linear-gradient(45deg, #27ae60, #229954);
            font-size: 0.9em;
            padding: 8px 16px;
        }

        .status-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            vertical-align: middle;
        }

        .status-good { background: #27ae60; }
        .status-damaged { background: #e74c3c; }
        .status-repairing { background: #f39c12; animation: pulse 1s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .upload-area {
            border: 3px dashed #3498db;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #2980b9;
        }

        .upload-area.dragover {
            background: rgba(52, 152, 219, 0.2);
            border-color: #e74c3c;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }

        .math-box {
            background: linear-gradient(135deg, #ff9a9e, #fecfef);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 5px solid #e91e63;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .step-indicator {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            flex-wrap: wrap;
            gap: 10px;
        }

        .step {
            flex: 1;
            min-width: 120px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .step.active {
            background: rgba(52, 152, 219, 0.3);
            transform: translateY(-5px);
        }

        .step.complete {
            background: rgba(39, 174, 96, 0.3);
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .demo-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            input, button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî≤ Live QR Code Error Correction Demo</h1>

        <div class="section">
            <h2>üöÄ Interactive QR Code Generator & Error Fixer</h2>
            <div class="live-demo">
                <div class="demo-controls">
                    <input type="text" id="qrText" placeholder="Enter text to encode..." value="HELLO WORLD">
                    <select id="errorLevel">
                        <option value="L">Low (7% recovery)</option>
                        <option value="M" selected>Medium (15% recovery)</option>
                        <option value="Q">Quartile (25% recovery)</option>
                        <option value="H">High (30% recovery)</option>
                    </select>
                    <button onclick="generateQR()">Generate QR</button>
                </div>

                <div class="step-indicator">
                    <div class="step" id="step1">üìù Encode</div>
                    <div class="step" id="step2">üîß Add Redundancy</div>
                    <div class="step" id="step3">üéØ Generate Pattern</div>
                    <div class="step" id="step4">‚úÖ Complete</div>
                </div>

                <div class="qr-workspace">
                    <div class="qr-display">
                        <h3><span class="status-indicator status-good"></span>Original QR Code</h3>
                        <canvas id="originalQR" class="qr-canvas" width="300" height="300"></canvas>
                        <div class="qr-info" id="originalInfo">Generate a QR code to start...</div>
                    </div>

                    <div class="qr-display">
                        <h3><span class="status-indicator status-damaged"></span>Damaged QR Code</h3>
                        <canvas id="damagedQR" class="qr-canvas" width="300" height="300"></canvas>
                        <div class="damage-controls">
                            <button class="damage-btn" onclick="addRandomDamage(10)">Light Damage (10%)</button>
                            <button class="damage-btn" onclick="addRandomDamage(20)">Heavy Damage (20%)</button>
                            <button class="damage-btn" onclick="addRandomDamage(30)">Extreme Damage (30%)</button>
                            <button class="damage-btn" onclick="addCustomDamage()">Draw Damage</button>
                        </div>
                        <div class="qr-info" id="damagedInfo">Click above to add damage...</div>
                    </div>

                    <div class="qr-display">
                        <h3><span class="status-indicator status-repairing"></span>Repaired QR Code</h3>
                        <canvas id="repairedQR" class="qr-canvas" width="300" height="300"></canvas>
                        <div class="progress-bar">
                            <div class="progress-fill" id="repairProgress"></div>
                        </div>
                        <button class="repair-btn" onclick="repairQR()" id="repairBtn">üîß Repair QR Code</button>
                        <div class="qr-info" id="repairInfo">Repair damaged QR to see recovery...</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üì§ Upload Your Own QR Code</h2>
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                <h3>üñºÔ∏è Drop QR Code Image Here</h3>
                <p>Or click to select file</p>
                <input type="file" id="fileInput" style="display: none;" accept="image/*" onchange="handleFileUpload(event)">
            </div>
            
            <div class="qr-workspace" id="uploadedQRSection" style="display: none;">
                <div class="qr-display">
                    <h3>üì∑ Uploaded QR Code</h3>
                    <canvas id="uploadedQR" class="qr-canvas" width="300" height="300"></canvas>
                    <div class="qr-info" id="uploadedInfo">Processing uploaded image...</div>
                </div>

                <div class="qr-display">
                    <h3>üîç Analysis Results</h3>
                    <canvas id="analyzedQR" class="qr-canvas" width="300" height="300"></canvas>
                    <button onclick="analyzeUploadedQR()">üî¨ Analyze QR Code</button>
                    <div class="qr-info" id="analysisInfo">Click analyze to inspect QR structure...</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üßÆ Mathematical Foundation</h2>
            
            <div class="grid-container">
                <div class="math-box">
                    <h3>Reed-Solomon Error Correction</h3>
                    <div class="formula">
Generator Polynomial:
$g(x) = \prod_{i=0}^{n-k-1} (x - \alpha^i)$

Where:
- $\alpha$ = primitive element in GF(256)
- $n$ = total codeword length
- $k$ = message length
- $t = \lfloor(n-k)/2\rfloor$ error correction capacity
                    </div>
                </div>

                <div class="math-box">
                    <h3>Error Detection Algorithm</h3>
                    <div class="formula">
Syndrome Calculation:
$S_i = r(\alpha^i)$ for $i = 1,2,...,2t$

If all $S_i = 0$: No errors
Else: Solve error locator polynomial
$\Lambda(x) = \prod_{j=1}^{v} (1 - X_j x)$

Error positions: $\alpha^{-i}$ where $\Lambda(\alpha^{-i}) = 0$
                    </div>
                </div>
            </div>

            <div class="math-box">
                <h3>Live Calculation Example</h3>
                <div class="formula" id="liveCalculation">
Generate a QR code to see Reed-Solomon calculations in real-time...
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üéØ How It Works</h2>
            <div class="grid-container">
                <div class="math-box">
                    <h3>1. Pattern Recognition</h3>
                    <p>QR codes use finder patterns with a specific 1:1:3:1:1 ratio to establish orientation and size. The algorithm scans for these patterns first.</p>
                </div>
                
                <div class="math-box">
                    <h3>2. Data Extraction</h3>
                    <p>Once patterns are found, the algorithm reads data in a zigzag pattern, applying the appropriate mask to recover the original binary data.</p>
                </div>
                
                <div class="math-box">
                    <h3>3. Error Correction</h3>
                    <p>Reed-Solomon codes detect and correct errors by evaluating polynomials at specific points in the Galois field GF(256).</p>
                </div>
                
                <div class="math-box">
                    <h3>4. Data Recovery</h3>
                    <p>Using syndrome decoding, the algorithm locates and corrects corrupted bits, recovering the original message even with significant damage.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentQRData = null;
        let originalMatrix = null; // This will now store the raw binary matrix from qrcode.js
        let damagedMatrix = null;
        let isDrawingDamage = false;

        // Function to draw a binary matrix onto a canvas
        function drawMatrix(canvas, matrix, highlight = false) {
            const ctx = canvas.getContext('2d');
            const size = matrix.length;
            const cellSize = canvas.width / size;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    let color = matrix[i][j] ? '#2c3e50' : '#ecf0f1'; // Black or White
                    
                    if (highlight) {
                        // Highlight finder patterns (simplified for visual demo)
                        if ((i < 7 && j < 7) || (i < 7 && j > size - 8) || (i > size - 8 && j < 7)) {
                            color = '#27ae60'; // Green for finder patterns
                        }
                        // Highlight timing patterns (simplified for visual demo)
                        if (i === 6 || j === 6) {
                            color = '#3498db'; // Blue for timing patterns
                        }
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
                    
                    // Add border
                    ctx.strokeStyle = '#bdc3c7';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(j * cellSize, i * cellSize, cellSize, cellSize);
                }
            }
        }

        // Helper to convert an image data object (from canvas.getImageData) to a binary matrix
        function imageDataToMatrix(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const matrix = [];
            
            for (let y = 0; y < height; y++) {
                matrix[y] = [];
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    
                    // Convert to grayscale and threshold
                    const gray = (r + g + b) / 3;
                    matrix[y][x] = gray < 128 ? 1 : 0;
                }
            }
            return matrix;
        }

        function generateQR() {
            const text = document.getElementById('qrText').value || 'HELLO WORLD';
            const errorLevel = document.getElementById('errorLevel').value;
            const originalCanvas = document.getElementById('originalQR');
            const damagedCanvas = document.getElementById('damagedQR');
            const repairedCanvas = document.getElementById('repairedQR');

            // Animate steps
            animateSteps();
            
            // Clear canvases before generating new QR
            originalCanvas.getContext('2d').clearRect(0, 0, originalCanvas.width, originalCanvas.height);
            damagedCanvas.getContext('2d').clearRect(0, 0, damagedCanvas.width, damagedCanvas.height);
            repairedCanvas.getContext('2d').clearRect(0, 0, repairedCanvas.width, repairedCanvas.height);

            // Generate QR code using qrcode.js
            try {
                // qrcode.js draws directly to canvas. To get a matrix, we need to read it back.
                QRCode.toCanvas(originalCanvas, text, {
                    errorCorrectionLevel: errorLevel,
                    margin: 1,
                    scale: 4 // Scale up for better resolution, then read back
                }, function (error) {
                    if (error) {
                        console.error('QR Code generation failed:', error);
                        document.getElementById('originalInfo').textContent = 'Error generating QR code.';
                        return;
                    }

                    // Read the generated QR code back into a matrix for damage simulation
                    const ctx = originalCanvas.getContext('2d');
                    const imageData = ctx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
                    originalMatrix = imageDataToMatrix(imageData);
                    
                    currentQRData = { text, errorLevel, matrix: originalMatrix };
                    
                    // Draw original QR (re-draw to ensure consistent styling if needed, or just keep the qrcode.js output)
                    // drawMatrix(originalCanvas, originalMatrix); // Not strictly necessary if qrcode.js drew it correctly

                    // Update info
                    updateQRInfo('originalInfo', {
                        text: text,
                        errorLevel: errorLevel,
                        size: `${originalMatrix.length}x${originalMatrix.length}`,
                        capacity: calculateCapacity(errorLevel),
                        binary: 'Generated by qrcode.js' // We don't have direct binary string easily
                    });
                    
                    // Clear damaged and repaired
                    document.getElementById('damagedInfo').textContent = 'Click damage buttons to corrupt the QR code...';
                    document.getElementById('repairInfo').textContent = 'Damage the QR code first, then repair...';
                    
                    // Update live calculation
                    updateLiveCalculation(text, errorLevel);
                });

            } catch (e) {
                console.error("Error generating QR code:", e);
                document.getElementById('originalInfo').textContent = 'Error generating QR code: ' + e.message;
            }
        }

        function animateSteps() {
            const steps = ['step1', 'step2', 'step3', 'step4'];
            steps.forEach((step, index) => {
                const element = document.getElementById(step);
                element.className = 'step'; // Reset class
                
                setTimeout(() => {
                    element.classList.add('active');
                    setTimeout(() => {
                        element.classList.remove('active');
                        element.classList.add('complete');
                    }, 500);
                }, index * 300);
            });
        }

        function updateQRInfo(elementId, info) {
            const element = document.getElementById(elementId);
            element.textContent = `Text: "${info.text}"
Error Level: ${info.errorLevel}
Size: ${info.size}
Recovery: ${info.capacity}
Info: ${info.binary || 'N/A'}`;
        }

        function calculateCapacity(level) {
            const capacities = {
                'L': '~7% damage recovery',
                'M': '~15% damage recovery', 
                'Q': '~25% damage recovery',
                'H': '~30% damage recovery'
            };
            return capacities[level];
        }

        function addRandomDamage(percentage) {
            if (!originalMatrix) {
                console.warn('Generate a QR code first!');
                document.getElementById('damagedInfo').textContent = 'Generate a QR code first!';
                return;
            }
            
            damagedMatrix = originalMatrix.map(row => [...row]);
            const size = damagedMatrix.length;
            const totalCells = size * size;
            const damageCells = Math.floor(totalCells * percentage / 100);
            
            let damagedCount = 0;
            // Add random damage
            for (let i = 0; i < damageCells; i++) {
                const row = Math.floor(Math.random() * size);
                const col = Math.floor(Math.random() * size);
                
                // Avoid damaging critical finder patterns and timing patterns for a more realistic demo
                if (!isCriticalArea(row, col, size)) {
                    damagedMatrix[row][col] = Math.random() > 0.5 ? 1 : 0; // Flip bit randomly
                    damagedCount++;
                }
            }
            
            drawMatrix(document.getElementById('damagedQR'), damagedMatrix);
            
            document.getElementById('damagedInfo').textContent = 
                `Damaged: ${percentage}% corruption applied
Actual affected cells: ${damagedCount}
Status: Needs repair
Recovery possible: ${percentage <= (currentQRData.errorLevel === 'H' ? 30 : currentQRData.errorLevel === 'Q' ? 25 : currentQRData.errorLevel === 'M' ? 15 : 7) ? 'YES (within error correction capacity)' : 'MAYBE (might exceed capacity)'}`;
        }

        // Helper to prevent damaging critical QR elements
        function isCriticalArea(row, col, size) {
            // Finder patterns and quiet zone around them
            if ((row < 9 && col < 9) || (row < 9 && col > size - 9) || (row > size - 9 && col < 9)) return true;
            // Timing patterns
            if (row === 6 || col === 6) return true;
            // Alignment patterns (for larger QR codes, simplified check)
            if (size > 21 && ((row > size - 10 && col > size - 10) || (row > size - 10 && col < 10) || (row < 10 && col > size - 10))) return true;
            return false;
        }

        function addCustomDamage() {
            if (!originalMatrix) {
                console.warn('Generate a QR code first!');
                document.getElementById('damagedInfo').textContent = 'Generate a QR code first!';
                return;
            }
            
            damagedMatrix = originalMatrix.map(row => [...row]);
            const canvas = document.getElementById('damagedQR');
            
            canvas.style.cursor = 'crosshair';
            isDrawingDamage = true;
            
            canvas.onmousedown = startDrawing;
            canvas.onmousemove = drawDamage;
            canvas.onmouseup = stopDrawing;
            canvas.onmouseleave = stopDrawing; // Stop drawing if mouse leaves canvas
            
            document.getElementById('damagedInfo').textContent = 'Click and drag on the damaged QR code to add custom damage!';
        }

        function startDrawing(e) {
            if (!isDrawingDamage) return;
            drawDamage(e);
        }

        function drawDamage(e) {
            if (!isDrawingDamage || e.buttons !== 1) return;
            
            const canvas = document.getElementById('damagedQR');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const size = damagedMatrix.length;
            const cellSize = canvas.width / size;
            const row = Math.floor(y / cellSize);
            const col = Math.floor(x / cellSize);
            
            if (row >= 0 && row < size && col >= 0 && col < size) {
                // Create damage pattern (e.g., a 3x3 square)
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const newRow = row + i;
                        const newCol = col + j;
                        if (newRow >= 0 && newRow < size && newCol >= 0 && newCol < size) {
                            if (!isCriticalArea(newRow, newCol, size)) {
                                damagedMatrix[newRow][newCol] = Math.random() > 0.5 ? 1 : 0; // Flip bit randomly
                            }
                        }
                    }
                }
                
                drawMatrix(canvas, damagedMatrix);
            }
        }

        function stopDrawing() {
            isDrawingDamage = false;
            const canvas = document.getElementById('damagedQR');
            canvas.style.cursor = 'default';
            canvas.onmousedown = null;
            canvas.onmousemove = null;
            canvas.onmouseup = null;
            canvas.onmouseleave = null;
            
            document.getElementById('damagedInfo').textContent = 
                `Custom damage applied.
Status: Ready for repair.
Click repair button to fix.`;
        }

        async function repairQR() {
            if (!damagedMatrix) {
                console.warn('Add some damage first!');
                document.getElementById('repairInfo').textContent = 'Add some damage first!';
                return;
            }
            
            const progressBar = document.getElementById('repairProgress');
            const repairBtn = document.getElementById('repairBtn');
            const repairedCanvas = document.getElementById('repairedQR');
            const repairedCtx = repairedCanvas.getContext('2d');

            repairBtn.disabled = true;
            repairBtn.textContent = 'üîß Repairing...';
            
            // Simulate repair process with animation
            let progress = 0;
            progressBar.style.width = '0%'; // Reset progress bar
            const repairInterval = setInterval(() => {
                progress += 2;
                progressBar.style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(repairInterval);
                    
                    // Convert damaged matrix back to imageData for jsQR
                    const damagedTempCanvas = document.createElement('canvas');
                    damagedTempCanvas.width = damagedMatrix.length;
                    damagedTempCanvas.height = damagedMatrix.length;
                    drawMatrix(damagedTempCanvas, damagedMatrix); // Draw to temp canvas
                    const damagedImageData = damagedTempCanvas.getContext('2d').getImageData(0, 0, damagedTempCanvas.width, damagedTempCanvas.height);

                    // Attempt to decode the damaged QR code using jsQR
                    const code = jsQR(damagedImageData.data, damagedImageData.width, damagedImageData.height);

                    if (code) {
                        // If successfully decoded, generate a new QR from the recovered data
                        repairedCtx.clearRect(0, 0, repairedCanvas.width, repairedCanvas.height);
                        QRCode.toCanvas(repairedCanvas, code.data, {
                            errorCorrectionLevel: currentQRData.errorLevel,
                            margin: 1,
                            scale: 4
                        }, function (error) {
                            if (error) {
                                console.error('Error re-generating repaired QR:', error);
                                document.getElementById('repairInfo').textContent = 'Repair failed: Could not re-generate QR.';
                            } else {
                                document.getElementById('repairInfo').textContent = 
                                    `Repair complete!
Decoded Text: "${code.data}"
Version: ${code.version}
Error Correction Level: ${code.version > 0 ? code.errorCorrectionLevel : 'N/A'}
Status: SUCCESS (QR code recovered!)`;
                            }
                        });
                    } else {
                        document.getElementById('repairInfo').textContent = `Repair failed!
Could not decode QR code.
Damage might be too extensive for current error correction level.`;
                    }
                    
                    repairBtn.disabled = false;
                    repairBtn.textContent = 'üîß Repair Again';
                    
                    setTimeout(() => {
                        progressBar.style.width = '0%';
                    }, 2000);
                }
            }, 50);
        }

        function updateLiveCalculation(text, errorLevel) {
            // This section is illustrative, as qrcode.js handles actual encoding details.
            // We can provide a theoretical estimate based on the text length and error level.
            const textLength = text.length;
            const redundancyFactor = { 'L': 0.07, 'M': 0.15, 'Q': 0.25, 'H': 0.30 }[errorLevel];
            
            // Simplified estimation for demonstration
            const estimatedDataBits = textLength * 8; // Roughly 8 bits per character
            const estimatedErrorCorrectionBits = Math.ceil(estimatedDataBits * redundancyFactor / (1 - redundancyFactor));
            const estimatedTotalBits = estimatedDataBits + estimatedErrorCorrectionBits;

            document.getElementById('liveCalculation').innerHTML = `
Current Text: "${text}"
Estimated Data Bits: ${estimatedDataBits}
Error Level: ${errorLevel} (${(redundancyFactor * 100).toFixed(0)}% redundancy)
Estimated Error Correction Bits: ${estimatedErrorCorrectionBits}
Estimated Total Bits: ${estimatedTotalBits}

Reed-Solomon Parameters (Conceptual):
- Message length (k): Approx. ${estimatedDataBits}
- Error correction length (n-k): Approx. ${estimatedErrorCorrectionBits}
- Maximum correctable errors: Approx. ${Math.floor(estimatedErrorCorrectionBits / 2)}
- Generator polynomial degree: Approx. ${estimatedErrorCorrectionBits}
            `.trim();
        }

        // File upload handling
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    displayUploadedQR(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function displayUploadedQR(img) {
            const canvas = document.getElementById('uploadedQR');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions to match image, or a fixed size if preferred
            canvas.width = img.width;
            canvas.height = img.height;
            if (canvas.width > 300 || canvas.height > 300) { // Scale down if too large for display
                const aspectRatio = img.width / img.height;
                if (aspectRatio > 1) {
                    canvas.width = 300;
                    canvas.height = 300 / aspectRatio;
                } else {
                    canvas.height = 300;
                    canvas.width = 300 * aspectRatio;
                }
            } else {
                 canvas.width = 300; // Default size if smaller
                 canvas.height = 300;
            }
            
            // Clear and draw uploaded image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Show the section
            document.getElementById('uploadedQRSection').style.display = 'grid'; // Use grid for layout
            
            document.getElementById('uploadedInfo').textContent = `
Uploaded QR Code
Original Size: ${img.width} x ${img.height} pixels
Displayed Size: ${canvas.width.toFixed(0)} x ${canvas.height.toFixed(0)} pixels
Status: Ready for analysis
Click 'Analyze QR Code' to inspect structure`;

            // Clear previous analysis results
            document.getElementById('analyzedQR').getContext('2d').clearRect(0,0,300,300);
            document.getElementById('analysisInfo').textContent = 'Click analyze to inspect QR structure...';
        }

        function analyzeUploadedQR() {
            const uploadedCanvas = document.getElementById('uploadedQR');
            const uploadedCtx = uploadedCanvas.getContext('2d');
            const imageData = uploadedCtx.getImageData(0, 0, uploadedCanvas.width, uploadedCanvas.height);
            
            const analyzedCanvas = document.getElementById('analyzedQR');
            const analyzedCtx = analyzedCanvas.getContext('2d');

            // Attempt to decode the uploaded QR code using jsQR
            const code = jsQR(imageData.data, imageData.width, imageData.height);

            if (code) {
                // Draw the QR code again on the analyzed canvas, highlighting detected patterns
                // jsQR provides location data, which is useful for highlighting
                analyzedCtx.clearRect(0, 0, analyzedCanvas.width, analyzedCanvas.height);
                analyzedCtx.drawImage(uploadedCanvas, 0, 0, analyzedCanvas.width, analyzedCanvas.height); // Draw original image

                // Draw bounding box
                analyzedCtx.lineWidth = 4;
                analyzedCtx.strokeStyle = "#00FF00"; // Green for detected
                analyzedCtx.beginPath();
                analyzedCtx.moveTo(code.location.topLeftCorner.x, code.location.topLeftCorner.y);
                analyzedCtx.lineTo(code.location.topRightCorner.x, code.location.topRightCorner.y);
                analyzedCtx.lineTo(code.location.bottomRightCorner.x, code.location.bottomRightCorner.y);
                analyzedCtx.lineTo(code.location.bottomLeftCorner.x, code.location.bottomLeftCorner.y);
                analyzedCtx.lineTo(code.location.topLeftCorner.x, code.location.topLeftCorner.y);
                analyzedCtx.stroke();

                // Draw points
                analyzedCtx.fillStyle = "#FF0000"; // Red for points
                analyzedCtx.fillRect(code.location.topLeftCorner.x - 5, code.location.topLeftCorner.y - 5, 10, 10);
                analyzedCtx.fillRect(code.location.topRightCorner.x - 5, code.location.topRightCorner.y - 5, 10, 10);
                analyzedCtx.fillRect(code.location.bottomLeftCorner.x - 5, code.location.bottomLeftCorner.y - 5, 10, 10);
                
                document.getElementById('analysisInfo').textContent = `
QR Code Analysis:
Decoded Text: "${code.data}"
Version: ${code.version}
Error Correction Level: ${code.errorCorrectionLevel}
Status: Successfully decoded!
Confidence: High

Pattern Analysis:
- Top-left finder: ‚úÖ
- Top-right finder: ‚úÖ
- Bottom-left finder: ‚úÖ
- Timing patterns: ‚úÖ (implied by successful decode)`;
            } else {
                // If decoding fails, just draw the original image and report failure
                analyzedCtx.clearRect(0, 0, analyzedCanvas.width, analyzedCanvas.height);
                analyzedCtx.drawImage(uploadedCanvas, 0, 0, analyzedCanvas.width, analyzedCanvas.height);
                
                document.getElementById('analysisInfo').textContent = `
QR Code Analysis:
Status: Failed to decode!
Reason: QR code not found or too damaged.
Recommendation: Try a clearer image or a less damaged QR code.

Pattern Analysis:
- Top-left finder: ‚ùå
- Top-right finder: ‚ùå
- Bottom-left finder: ‚ùå
- Timing patterns: ‚ùå (likely)`;
            }
        }

        // Drag and drop functionality
        const uploadArea = document.getElementById('uploadArea');
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                const event = { target: { files: files } };
                handleFileUpload(event);
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof QRCode === 'undefined') {
                console.error("Error: qrcode.js library (QRCode object) is not defined. Please ensure it's loaded correctly.");
                document.getElementById('originalInfo').textContent = 'Error: QR Code generator library not loaded.';
            } else {
                generateQR();
            }
        });
    </script>
</body>
</html>
